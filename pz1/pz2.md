## Практическое занятие №2. Основные типы данных в Python. Структуры данных

### Рассматриваемые вопросы
1. int
2. bool
3. str
4. None
5. if, for, while, def
6. Списки
7. Кортежи
8. Словари
9. Множества

Во время работы пользоваться системой контроля версий. Каждые 3-5 строк кода должны входить в очередной коммит в git, каждые несколько коммитов завершаться git push. Такой подход избавляет от проблем уровня "повисла виртуалка" и иных недоразумений.

Весь проработанный материал должен быть добавлен в личный репозиторий и запушен на gitwork.

### 
Проходим [тестирование по ПЗ1 и ДЗ книги](http://gitlab:5000/python/pz1?pin=)

### Домашнее задание

Книга "Python К вершинам мастерства". Глава 2 и Глава 3 (стр. 44-124)

Необходимо усвоить:

* Особенности работы с кортежами (распаковка, *, именованные)
* Особенности работы со срезами
* Понимание sort
* Особенности работы с массивами
* Особенности dict, set (хеширование, setdefault, производительность и ограничения) 

### Корректируем организацию репозитория

Угадайку из ПЗ1 нужно перенести в pz1/guesser.py, сама функци-угадайка должна называться main.

### Числовой тип данных - int
Из первого занятия вы знакомы со справкой help() или pydoc, с помощью dir() вы можете изучать любой объект. Примеры численных типов данных

```python
a = 100
b = 36.6
c = 15 + 2j
```
С помощью type() определите, какими типами данных являются переменные a, b и c. Основные операции:

```python
a + b
a * b
a ** b  # возведение в степень
102 / 10
102 // 10  # целочисленное деление
c.real
c.imag
```
Имеются и битовые операции |, \^, &, <<, >>, ~.

Используем знакомую нам функцию dir для числа

```python
num = 7
dir(a)
```
Для переменной num определено множество методов. Напрашивается вопрос, как вообще переменные могут обладать методами. Ответ - в особенности устройства языка Python. Переменные является объектами. На C-уровне определена структура PyObject:

```c
typedef struct _object {
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt; // Счетчик ссылок
    struct _typeobject *ob_type; // Указатель на тип объекта
} PyObject;
```
Эта структура содержит два важных поля. Поле ob_refcnt - счётчик ссылок, и когда мы создаём новую связь переменной с объектом, он увеличивается на единицу. Если какая-то связь становится не нужна, соответствующий счётчик ссылок на единицу уменьшается. Когда он достигает нуля, объект удаляется из памяти. Так в Python организована автоматическая сборка мусора. Второе важное поле - указатель на тип объекта. Этот указатель может менять своё значение в процессе работы программы, и именно таким образом в Python реализована динамическая типизация.

Также реализованы не только простые типы данных, но модули, функции и классы. Все они являются объектами со своими методами и атрибутами. Из этого следует, то что в Python любой объект можно присвоить переменной или передать как аргумент в функцию.

### Логический тип данных - bool
Логический тип данных представлен значениями True и False. Обратите внимание на заглавную первую букву.

```python
3 > 4
3 >= 6
3 >= 3
x = 5
# поддерживаются даже такие конструкции
3 < x < 10
8 < x < 10
```
Логические операции представлены словами and, or, not. То есть не x будет написано как not x, что существенно повышает читаемость кода. Важный нюанс - результат работы логических операций and и or не является bool. Python сохраняет численное значение определяющего аргумента, например,

```python
5 and 2 == 2
5 or 2 == 5

```

Сформулируем выражение для определения високосного года. Год високосный, если он кратен 4, но при этом не кратен 100, либо кратен 400.

```python
year = 2019
is_leap = year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)
print(is_leap)
```
Но это не Python-style, как говорят. В модуле calender есть функция isleap для определения високосного года.

```python
import calendar

print(calendar.isleap(2019))
print(calendar.isleap(1980))
```
### Строки - str

```python
a = 'это строка'
b = "и это строка"  # просто внутри можно использовать одинарную кавычку без экранирования
c = """и это строка
но во много строк
"""

# строки можно просто складывать
d = a + b

# можно получать подстроки разного вида
e = a[0:3]
```
Последняя операция - так называемые срезы (slices). Общий вид у неё такой str[start:stop:step]. При этом по умолчанию start=0, stop=длине строки, step=1, и эти значения можно не указывать. Попробуйте примеры ниже:

```python
a = '1234567890'
a[5:7]
a[:5]
a[5:]
a[::2]
```
Операция срезов настолько удобная, что используется повсеместно. При этом в скобках допускаются отрицательные символы, что значит "с конца". Например:

```python
a[-3:]  # только 3 последних символа
a[:-3]  # всё, кроме трёх последних
a[::-1]  # строка в обратном порядке
```
Ещё ряд полезных методов для строк

```python
len(b)
b.upper()

# проверка наличия подстроки в строке
if 'строка' in b:
    print('нашёл')
    
# итерация по буквам
for letter in c:
    print('Нашёл букву ', letter)
```
Метод str() позволяет получить строку из любого объекта, а метод int() позволяет получить целое число из строки. Есть возможность разбить строку на части, разделённые любым символом (или группой символов). Результатом является список, этот тип данных мы расмотрим ниже. Но Питон поддерживает множественное присваивание, воспользуемся им. После каждой строки проверяйте содержимое a и b.

```python
# множественное присваивание
a, b = 7, 17
# кстати, так можно менять переменные местами
a, b = b, a

a, b = 'моя строка'.split(' ')
a, b = '1234'.split('23')
```

Существуют несколько способов форматирования строк

```python
answer = input('Введите число: ')
print('Вы ввели %s' % answer)
# если нужно подставить 2 строки, то синтаксис чуть сложнее
print('Вы ввели %s. Точно %s?' % (answer, answer))

print ('Форматировать ваш ответ {0} можно и так'.format(answer))

print ('Если много подстановок, то в порядке аргументов можно запутаться. Их можно именовать. А вы ввели {number}. Но вариантов больше, чем {count}'.format(number=answer, count=5))

# доступно с Python3.6 - так называемые f-строки
subject = 'оптимизация'
author = 'Дональд Кнут'
print(f'Преждевременная {subject} - корень всех зол. {author})
```


### Объект None
Аналог нулевого указателя в C. Например, если данных ещё нет, можно использовать None. Важным нюансом является проверка на None, которая выглядит так

```python
if answer is None:
    print('Ответа ещё нет')
```
Оператор is проверяет, является ли объект тем же самым (то есть одинаков ли у них id). Очевидно, что Питон не создаёт множество различных None-объектов, а всегда пользуется одним и тем же.

### Операторы условных переходов if, for, while. Создание функций
Перед вами пример небольшой программы Определятор, который необходимо разместить в файле pz2/group.py. Определена функция, которая умеет распознавать 3, 4 и 5 группы третьего курса. В main циклом for просматриваются ряд групп. После чего запрашивается пользовательский ввод до тех пор, пока не будет введено exit или q. Этот код демонстрирует простые моменты использования if, for, while и def.

```python
def group_parser(group):
    if not group.startswith('733'):
         print('Это не группа 3 курса')
        return
        
    if group.endswith('3'):
        print('%s - Третья группа' % group)
    elif group.endswith('4'):
        print('%s - Четверная группа' % group)
    elif group.endswith('5'):
        print('%s - Пятая группа' % group)
    else:
        print('%s - Непонятная группа' % group)

def main():
    """Определятор"""
    group_parser('abc')
    for group_num in range(7331, 7336):
        group = str(group_num)
        group_parser(group)
        
    answer = input('Попробуйте выйти: ')
    while answer != 'exit' and answer != 'q':
        answer = input('Неправильно! Попробуйте ещё раз: ')
    print('Успех!')
    
if __name__ == '__main__':
    main()
```

### Списки

Коллекция - это переменная-контейнер, в которой может содержаться какое-то количество объектов, где объекты могут быть одного типа или разного. В случае списков это упорядоченные наборы элементов, которые могут быть разных типов. Сами списки определяются с помощью квадратных скобочек или с помощью вызова литерала list. Вы также можете создать список из одинаковых значений с помощью умножения. Несмотря на вышесказанное, чаще всего списки содержат переменные одного типа. Также списки могут содержать другие коллекции.

```python
empty_list = [] 
empty_list = list() 
none_list = [None] * 10 
collections = ['list', 'tuple', 'dict', 'set'] 
user_data = [ 
['Elena', 4.4], 
['Andrey', 4.2] 
] 
```

Для получения длины списка вызывают встроенную функцию len(). В Python не нужно явно указывать размер списка или вручную выделять на него память. Размер списка хранится в структуре, с помощью которой реализован тип список, поэтому длина вычисляется за константное время. При этом вспомним dir. В выводе dir найдите "магический" метод определения размера списка.

```python
len(collections)
dir(collections)
collections.__len__()  # эквивалентно len(collections), но куда изящнее
```

Чтобы обратиться к конкретному элементу списка, мы используем тот же механизм, что и для строк - обращаемся к элементу по индексу. Нумерация элементов начинается с нуля. Отрицательные элементы всё также значат "с конца". 

```python
print(collections) 
print(collections[0]) 
print(collections[-1]) 
```

Допускаются присваивания по индексу.

```python
collections[3] = 'frozenset'
```

Обращение к несуществующему индексу приводит к ошибке IndexError: list index out of range. 

```python
collections[20]  # порождается исключение
```

С помощью оператора in можно проверить, существует ли какой-то объект в списке: 

```python
'tuple' in collections 
```

Срезы в списках работают точно так же, как и в строках. Создадим список из 10 элементов с помощью встроенной функции range и поэкспериментируем на нём со срезами:

```python
range_list = list(range(10)) 
print(range_list) 
range_list[1:3] 
range_list[::2] 
range_list[::-1] 
range_list[5:1:-1] 
```

Важно знать, что при получении среза создаётся новый объект - новый список:

```python
range_list[:] is range_list  # возвращает False
```

Как и все коллекции, списки поддерживают итерирование. Обратите внимание, что итерация производится именно по элементам списка, а не по индексам, как во многих других языках. 

```python
collections = ['list', 'tuple', 'dict', 'set'] 
for collection in collections: 
    print('Learning {0}...'.format(collection))
```

Часто бывает нужно получить индекс текущего элемента при итерации. Для этого можно использовать встроенную функцию enumerate, которая возвращает индекс и текущий элемент. 

```python
for idx, collection in enumerate(collections): 
    print('#{0} {1}'.format(idx, collection))
```

Так как списки являются изменяемой структурой данных, мы можем добавлять и удалять элементы. Например, мы можем добавить в наш список collections элемент 'OrderedDict'. 

```python
collections.append('OrderedDict') 
print(collections) 
```

Если вам нужно расширить список другим списком, вы можете использовать метод extend, который добавляет переданный список в конец вашего списка. 

```python
collections.extend(['ponyset', 'unicorndict']) 
print(collections) 
```

Также можно использовать перегруженный оператор +, который также добавляет переменную в конец вашего списка: 

```python
collections += [None] 
print(collections)
```

Для удаление элемента из списка можно использовать ключевое слово del. 

```python
del collections[4] 
print(collections)
```

Часто нам нужно найти минимальный/максимальный элемент в массиве или посчитать сумму всех элементов. Вы можете это сделать при помощи встроенных функций min, max, sum. Не забывайте, что это всё "магические" методы.

```python
numbers = [4, 17, 19, 9, 2, 6, 10, 13] 
print(min(numbers)) 
print(max(numbers)) 
print(sum(numbers)) 
```

Часто бывает полезно преобразовать список в строку, для этого можно использовать идиому str.join(): 

```python
tag_list = ['python', 'course', 'coursera'] 
print(', '.join(tag_list))
```

Ещё одна часто встречающаяся операция со списками - это сортировка. В Python существует несколько методов сортировки. Для начала создадим случайный список с помощью функции модуля random. Переменную для итерации называли _, т.к. сама эта переменная не используется.

```python
import random 
numbers = [] 
for _ in range(10):
    numbers.append(random.randint(1, 20)) 
print(numbers)
```

Для сортировки списка в Python есть два способа: стандартная функция sorted, которая возвращает новый список, полученный сортировкой исходного, и метод списка .sort(), который сортирует in-place. Для сортировки используется алгоритм TimSort. 

```python
print(sorted(numbers)) 
print(numbers)

numbers.sort() 
print(numbers)
```

Если нужно отсортировать список в обратном порядке:

```python
print(sorted(numbers, reverse=True)) 
numbers.sort(reverse=True) 
print(numbers) 
```

Для той же цели можно использовать встроенную функцию reversed, которая возвращает так называемый reverse iterator. Об итераторах будет сказано позднее, пока достаточно понимать, что это объект, который поддерживает протокол итерации. Данный объект можно преобразовать в список, и получится список с обратным порядком элементов. 

Кроме методов, которые мы обсудили выше, существует также много других, о которых 
можно прочесть в документации: 

* append 
* clear 
* copy 
* count 
* extend 
* index 
* insert 
* pop 
* remove 
* reverse 
* sort 

### Кортежи 

Кортежи - это неизменяемые списки (мы не можем ни добавлять, ни удалять элементы из кортежа). Кортежи определяются с помощью круглых скобок или литерала tuple.  Еще одним назначением кортежей является использование их в качестве записей с неименованными полями.

```python
empty_tuple = () 
empty_tuple = tuple() 
```

Например, мы можем создать кортеж immutables и поместить туда неизменяемые типы. 

```python
immutables = (int, str, tuple) 
```

Если попробовать заменить нулевой элемент на float, Python выдаст исключение TypeError, потому что кортежи неизменяемы. 

```python
immutables[0] = float  # порождается исключение
```

Но несмотря на то, что сами кортежи неизменяемые, объекты внутри них могут быть изменяемыми. Например, если кортеж содержит список, мы можем добавлять элементы в этот список. 

```python
blink = ([], []) 
blink[0].append(0) 
print(blink) 
```

Важная особенность кортежей - к ним применяется функция hash, и поэтому они могут использоваться в качестве ключей в словарях, о которых мы поговорим позднее. 

```python
hash(tuple())
```

Будьте внимательны при определении кортежа из одного элемента - не забывайте писать запятую. Если вы забудете про нее, Python сочтет вашу переменную типом int. 

```python
one_element_tuple = (1,) 
guess_what = (1) 
type(guess_what)
```

### Списки. Пример программы

Разберём задачу на применение списков - поиск медианы случайного списка. Медиана - это значение в отсортированном списке, которое лежит ровно посередине, таким образом, половина значений - слева от него, и половина значений - справа. 
Сначала создадим случайный список со случайным (чтобы было интереснее) количеством элементов. Функция randint возвращает случайное целое число в переданном ей интервале

```python
import random 
numbers = [] 
numbers_size = random.randint(10, 15) 
for _ in range(numbers_size): 
	numbers.append(random.randint(10, 20)) 
print(numbers) 
```

Отсортируем наш список: 

```python
numbers.sort() 
```

По определению медианы, она равна среднему элементу в отсортированном списке, если количество элементов нечётное. Если число элементов чётное, то медиана - это среднее арифметическое от двух средних элементов. Мы заведем переменную half_size, в которую положим значение, равное половине длины списка. Также заведём переменную median, сначала имеющую значение None. Запишем условие на чётность элементов и найдём медиану по определению для каждого случая

```python
numbers.sort() 
half_size = len(numbers) // 2 
median = None 
if numbers_size % 2 == 1: 
	median = numbers[half_size] 
else:
	median = sum(numbers[half_size - 1:half_size + 1]) / 2 
print(median) 
```

Чтобы проверить наш результат, можно воспользоваться встроенным модулем statistics. 

```python
import statistics 
statistics.median(numbers) 
```

Для обхода одновременно двух списков одинакового размера существует устойчивая идиома

```python
colors = ['white', 'blue', 'red']
worms = ['Ivan', 'Petr', 'Stepan']
for color, worm in zip(colors, worms):
    print('Worm {0} is colored in {1} ink'.format(worm, color))
```

### Словари

Словари являются важнейшей структурой данных в Python. Они позволяют хранить данные в формате ключ-значение. Чтобы определить словарь, нужно использовать литерал фигурные скобки или просто вызвать dict. Если мы хотим, определяя словарь, сразу добавить в него данные, пишем ключ-значение через двоеточие. 

```python
empty_dict = {} 
empty_dict = dict() 
collections_map = { 
    'mutable': ['list', 'set', 'dict'], 
    'immutable': ['tuple', 'frozenset'] 
} 
```

Доступ к значению по ключу осуществляется за константное время, то есть не зависит от размера словаря. Это достигается с помощью алгоритма хеширования. Если пытаться получить доступ по ключу, которого не существует, Python выдаст ошибку KeyError. Однако, часто бывает полезно попытаться достать значение по ключу из словаря, а в случае отсутствия ключа вернуть какое-то стандартное значение. Для этого есть встроенный метод get. 

```python
print(collections_map['immutable']) 
print(collections_map['irresistible'])  # исключение
```

Проверка на вхождения ключа в словарь так же осуществляется за константное время и выполняется с помощью ключевого слова in: 

```python
'mutable' in collections_map 
```

Так как словарь является изменяемой структурой данных, мы можем добавлять и удалять элементы из него. Например, мы можем определить словарь beatles_map, который содержит знаменитых музыкантов и их инструменты, и добавить в него Ринго с ударными, просто используя доступ по ключу. Чтобы удалить ключ и значение из словаря, можно использовать уже знакомый вам оператор del. 

```python
beatles_map = { 
    'Paul': 'Bass', 
    'John': 'Guitar', 
    'George': 'Guitar', 
}
print(beatles_map) 
beatles_map['Ringo'] = 'Drums' 
print(beatles_map) 
del beatles_map['John']
print(beatles_map) 
```

Также, чтобы добавить какой-то ключ-значение в словарь, можно использовать встроенный метод update, который принимает словарь и дополняет им (а также обновляет в случае одинаковых ключей) исходный словарь. 

```python
beatles_map.update({ 
'John': 'Guitar' 
}) 
print(beatles_map)
```

Чтобы удалить ключ-значение из словаря и одновременно вернуть значение, используют метод pop: 

```python
# удаляем Ринго, нам возвращаются его ударные 
print(beatles_map.pop('Ringo')) 
print(beatles_map) 
```

Часто бывает необходимо не только попробовать проверить, существует ли ключ в словаре, но и в случае неудачи добавить эту новую пару ключ-значение. Для этого есть метод setdefault: 

```python
unknown_dict = {} 
print(unknown_dict.setdefault('key', 'default')) 
print(unknown_dict) 
```

Если вызвать setdefault и в качестве дефолтного значения передать new_default, вернётся значение, которое уже лежит в словаре - значение default: 

```python
print(unknown_dict.setdefault('key', 'new_default'))
```

Словари, как и все коллекции, поддерживают протокол итерации. С помощью цикла for можно итерироваться по ключам словаря: 

```python
print(collections_map) 
for key in collections_map: 
    print(key) 
```

Если нам нужно итерироваться не по ключам, а по ключам и значениям сразу, можно использовать метод словаря items, который возвращает ключи и значения. 

```python
for key, value in collections_map.items(): 
	print('{0} — {1}'.format(key, value)) 
```

Если нужно итерироваться по значениям, используйте логично метод values, который возвращает именно значения. Также существует симметричный метод keys, который возвращает итератор ключей. 

```python
for value in collections_map.values(): 
    print(value) 
```

Важная особенность словарей в Python: они содержат ключи и значения в неупорядоченном виде. Однако, в Python существует тип OrderedDict (содержится в модуле collections), который гарантирует вам, что ключи хранятся именно в том порядке, в каком вы их добавили в словарь. **Замечание**. В python3.7 велись обсуждение, чтобы по умолчанию словарь был сортированным. Но в целом не стоит на это полагаться, в разных языках или даже разных версиях одного языка может быть по-разному. Всегда предполагайте, что обычный словарь не упорядочен.

```python
from collections import OrderedDict 
ordered = OrderedDict() 
for number in range(10): 
    ordered[number] = str(number) 
for key in ordered: 
    print(key)
```

### Словари. Пример программы 

Разберём следующую задачу на словари: найти 3 самых часто встречающихся слова в Zen of Python. 

```python
import this 
```

Скопируем этот текст и поместим его в переменную zen. После этого заведём переменную zen_map, в которой будем хранить слова, которые уже нашли, и то, сколько раз их уже нашли. Будем итерироваться с помошью метода split(), который разобьёт нашу строку по пробельным символам. Очищать слова от знаков препинания и пробельных символов будем с помощью метода strip().

```python
zen_map = dict() 
for word in zen.split(): 
cleaned_word = word.strip('.,!-*').lower() 
# добавляем слово, если его ещё нет в zen_map: 
if cleaned_word not in zen_map: 
    zen_map[cleaned_word] = 0 
    zen_map[cleaned_word] += 1 
print(zen_map) 
```

На выходе имеем словарь, в котором ключами являются слова, а значениями - сколько раз слова встретились в тексте. Теперь найдём самые частотные слова. В переменную zen_items поместим список кортежей (ключ, значение) с помощью метода items(). Затем отсортируем список по вторым элементам в кортеже, используя модуль operator. В метод sorted() в качестве аргумента key передадим operator.itemgetter(1) (т.к. мы сортируем по элементам с индексом 1). 

```python
import operator 
zen_items = zen_map.items() 
word_count_items = sorted( 
    zen_items, key=operator.itemgetter(1), reverse=True 
)
print(word_count_items[:3])
```

Как это часто бывает в Python, существует встроенный модуль, который поможет вам решить эту задачу намного быстрее. Импортируем Counter из модуля collections. Теперь осталось только "очистить" слова и передать их в Counter. 

```python
from collections import Counter 
cleaned_list = [] 
for word in zen.split(): 
    cleaned_list.append(word.strip('.,-!').lower()) 
print(Counter(cleaned_list).most_common(3))
```

### Множества

Множество в питоне — это неупорядоченный набор уникальных объектов. Множества изменяемы и чаще всего используются для удаления дубликатов и всевозможных проверок на вхождение. Чтобы объявить пустое множество, можно воспользоваться литералом set или использовать фигурные скобки, чтобы объявить множество и одновременно добавить туда какие-то элементы. 

```python
empty_set = set() 
number_set = {1, 2, 3, 3, 4, 5} 
print(number_set)
```

Чтобы проверить, содержится ли объект в множестве, используется уже знакомое нам ключевое слово in. Проверка выполняется за константное время, время выполнения операции не зависит от размера множества. Это достигается за счёт хэширования каждого элемента структуры по аналогии со словарями. По полученному от хэш-функции ключу и происходит поиск объекта. Таким образом, во множествах могут содержаться только хэшируемые объекты. 

```python
print(2 in number_set)
```

Чтобы добавить элемент в множество, используется метод add. Также множества в Python поддерживают стандартные операции над множествами - такие как объединение, разность, пересечение и симметрическая разность. Создадим два множества с чётными и нечётными числами до десяти: 

```python
odd_set = set() 
even_set = set() 
for number in range(10): 
    if number % 2: 
        odd_set.add(number) 
    else:
        even_set.add(number) 
print(odd_set) 
print(even_set) 
```

Теперь найдём объединение и пересечение этих множеств: 

```python
union_set = odd_set | even_set 
union_set = odd_set.union(even_set) 
print(union_set) 

intersection_set = odd_set & even_set 
intersection_set = odd_set.intersection(even_set) 
print(intersection_set) 
```

Найдём разность двух множеств: 

```python
difference_set = odd_set - even_set 
difference_set = odd_set.difference(even_set) 
print(difference_set)
```

Или симметрическую разность: 

```python
symmetric_difference_set = odd_set ^ even_set 
symmetric_difference_set = odd_set.symmetric_difference(even_set) 
print(symmetric_difference_set) 
```

Множества - изменяемая структура данных, поэтому можно как добавлять туда элементы, так и удалять. Для удаления конкретного элемента существует метод remove, для удаления любого элемента можно использовать pop. Остальные методы можно посмотреть в help или документации. 

```python
even_set.remove(2) 
print(even_set) 
even_set.pop() 
```

Также в питоне существует неизменяемый аналог типа set - тип frozenset. 

```python
frozen = frozenset(['Anna', 'Elsa', 'Kristoff']) 
frozen.add('Olaf')  # порождает исключение AttributeError
```

### Множества. Пример программы 

**Задача на множества**: через сколько итераций функция random.randint(1, 10) выдаст повтор? 

Будем добавлять неповторяющиеся случайные числа в множество random\_set. Если очередное число уже есть в random_set - выйдем из цикла. Затем посчитаем длину множества (и прибавим 1, т.к. не учли последнее число). 

```python
import random 
random_set = set() 
while True: 
    new_number = random.randint(1, 10) 
    if new_number in random_set: 
        break 
    random_set.add(new_number) 
print(len(random_set) + 1) 
```

### Функции

Функция - это блок кода, который можно переиспользовать несколько раз в разных местах программы. Мы можем передавать функции аргументы и получать возвращаемые значения. Чтобы определить функцию в языке Python, нужно использовать литерал def и с помощью отступа определить блок кода функции. По PEP8 функции называют snake\_case-ом. После объявления функции в тройных двойных кавычках задаётся описание функции, так называемый docstring. Из него автоматически формируется документация по модулю.

Объявим функцию, которая возвращает секундную часть текущего времени. 


```python
from datetime import datetime 
def get_seconds(): 
    """Return current seconds""" 
    return datetime.now().second 

get_seconds() 
```

Чтобы получить документационную строку, можно обратиться к атрибуту doc, а имя функции получается с помощью атрибута name. Остальные аттрибуты посмотрите с помощью dir.

```python
get_seconds.__doc__
get_seconds.__name__ 
```

Чаще всего функция определяется с параметрами, т.к. зачастую функции каким-то образом обрабатывают переданные им значения. Определим функцию split\_tags, которая принимает параметр tag_string (например, равный строке с тегами текущего курса). 

Пусть функция разобьёт эту строку по запятым и вернёт список тегов. 

```python
def split_tags(tag_string): 
    tag_list = [] 
    for tag in tag_string.split(','): 
        tag_list.append(tag.strip()) 
    return tag_list 

split_tags('python, coursera, mooc') 
```

При вызове этой же функции без параметров получаем ошибку, т.к. функция ожидает заявленный параметр и не может работать без него.

```python
split_tags()  # порождает исключение TypeError
```

Выше мы не указывали явно, какого типа параметры функция ожидает, потому что Python - это язык с динамической типизацией. Но, например, в языке C типы аннотируются, т.е. явно указывается, какого типа должен быть параметр функции и какого типа возвращаемые значения. В Python-е последних версий появилась возможность аннотировать типы, и делается это с помощью двоеточия в случае параметров, а стрелочкой указывают тип возвращаемого значения. Однако, если мы передадим в функцию параметры других типов, код все равно выполнится, потому что Python - это динамический язык, и аннотация типов призвана лишь помочь программисту или его IDE отловить какие-то ошибки. 

```python
def add(x: int, y: int) -> int: 
    return x + y 

print(add(10, 11)) 
print(add('still ', 'works'))  # работает, т.к. + для строк перегружен как конкатенация
print(add('do not work', 123)  # порождает исключение TypeError, т.к. операция строка+число не определена
```

Во многих других языках программирования значения параметра передаются в функцию либо по ссылке, либо по значению (и между двумя этими случаями проводится строгая граница). В Python каждая переменная является связью имени с объектом в памяти, и именно эта ссылка на объект передается в функцию. Таким образом, если мы передадим в функцию список и в ходе выполнения функции изменим его, этот список измениться глобально: 

```python
def extender(source_list, extend_list): 
    source_list.extend(extend_list) 

values = [1, 2, 3] 
extender(values, [4, 5, 6]) 
print(values) 
```

Если мы так же попытаемся изменить объект неизменяего типа, он, что логично, не изменится (мы передаем ссылку на объект в памяти, который неизменяем). 

```python
def replacer(source_tuple, replace_with): 
	source_tuple = replace_with 
	
user_info = ('Guido', '31/01') 
replacer(user_info, ('Larry', '27/09')) 
print(user_info) 
```

Однако изменение глобальных переменных внутри функции является плохим тоном, потому что часто бывает не очевидно, какие глобальные объекты как изменяются в каких функциях. В таких ситуациях советуют использовать возвращаемые значения. 

В Python также существуют именованные аргументы, которые иногда бывают полезны. Если явно указывать имена аргументов, можно передавать их в любом порядке. Кроме того, при вызове функции будет видно, каким аргументам мы присваиваем передаваемые значения. 

```python
def say(greeting, name): 
    print('{} {}!'.format(greeting, name)) 

say('Hello', 'Kitty') 
say(name='Kitty', greeting='Hello')
```

Важно понимать, что переменные, объявленные вне области видимости функции, нельзя изменять. 

```python
result = 0 
def increment(): 
    result += 1 
    return result 

print(increment())  # порождается исключение UnboundLocalError
```

В Python всё же есть возможность изменять глобальные переменные с помощью global или non local, но использовать эти особенности не рекомендуется. Глобальные переменные могут быть изменены из любого места программы, что усложняет отладку и замедляет скорость разработки.

Существует также возможность использовать аргументы по умолчанию, которые можно передавать, а можно не передавать. У этих аргументов, могут быть определены какие-то дефолтные значения, которые прописываются при объявлении функции: 

```python
def greeting(name='it\'s me...'): 
    print('Hello, {}'.format(name)) 

greeting() 
```

Стоит быть внимательными с аргументами по умолчанию, если мы используем в качестве их дефолтного значения объекты изменяемого типа. Например, объявим функцию, которая прибавляет к списку элемент 1. В качестве значения по умолчанию зададим пустой список: 

```python
def append_one(iterable=[]): 
    iterable.append(1) 
    return iterable 

print(append_one([1])) 
```

Что произойдёт, если мы вызовем эту функцию дважды: 

```python
print(append_one()) 
print(append_one()) 
```

Чтобы разобраться, проверим, каковы дефолтные значения параметров функции: 

```python
print(append_one.__defaults__) 
```

Почему так происходит? При определении функции, когда интерпретатор Python проходит по файлу с кодом, определяется связь между именем функции и дефолтными значениями. Таким образом, у каждой функции появляется tuple с дефолтными значениями. Именно в эти переменные каждый раз и происходит запись. Таким образом, если дефолтные значения являются изменяемыми, в них можно записывать, потому что это обычные переменные. Более того, анализатор кода в PyCharm также подскажет, что вы передали в качестве дефолтного значения изменяемый тип.

Чтобы исправить предыдущий пример, возьмём в качестве значения по умолчанию None одним из следующих способов: 

```python
def function(iterable=None): 
    if iterable is None: 
        iterable = [] 
    return iterable

def function(iterable=None): 
    iterable = iterable or []  # это важная идиома. Если iterable == None, в будет использовано []
    return iterable
```

Довольно красивой особенностью Python является возможность определения функции, которая принимает разные количества аргументов. Определим функцию printer, которая принимает любое количество аргументов - все аргументы записываются в tuple args. Затем функция печатает по порядку все аргументы: 

```python
def printer(*args): 
    print(type(args)) 

    for argument in args: 
        print(argument) 

printer(1, 2, 3, 4, 5) 
```

Также в аргументах можно развернуть список значений: 

```python
name_list = ['John', 'Bill', 'Amy'] 
printer(*name_list) 
```

Точно так же это работает в случае со словарями, в данном случае мы можем определить функцию printer, которая принимает разное количество именованных аргументов. При этом переменная kwargs будет иметь тип dict. 

```python
def printer(**kwargs): 
    print(type(kwargs)) 

    for key, value in kwargs.items(): 
        print('{}: {}'.format(key, value)) 

printer(a=10, b=11) 
```

Точно так же мы можем разыменовывать (разворачивать) словари, используя **: 

```python
payload = { 
    'user_id': 117, 
    'feedback': { 
        'subject': 'Registration fields', 
        'message': 'There is no country for old men' 
    } 
}

printer(**payload) 
```

Это используется практически везде и позволяет вам определять очень гибкие функции, которые принимают различное количество аргументов — именованных и позиционных. 

```python

```

### Самостоятельная работа

1. Написать функцию shout\_on\_me в pz2/shouter.py, которая просит пользователя ввести строку, а результат отправляет ему в верхнем регистре. Выход по вводу exit. Пример вывода такой:

    ```
    Что ты сказал? отойди
    Сам ты ОТОЙДИ. И не кричи на меня
    
    Что ты сказал?
    ```

1. Написать функцию-калькулятор calc в pz2/calc.py, реализующий операцию + (сложение). Пользователь вводит 1+4, ему возвращается 5. Выход по вводу exit. Пример вывода

    ```
    Введите выражение: 5+2
    7
    
    Введите выражение: 10+11
    21
    ```
    Подсказка: воспользуйтесь split и множественным присваиванием. В этом задании считайте, что обязательно два числа, между ними плюс, другие символы (в том числе пробел) не допускаются.

1. Доработайте Определятор так, чтобы группа считывалась из ввода пользователя. Функцию group_parser разместить в pz2/group.py. При запуске pz2/group.py, если ввести слово "угадайка" вместо номера группы - должна запуститься Угадайка по выбору числа из ПЗ1, при вводи "покричи" запускась функция shout\_on\_me из первого задания, при вводе "калькулятор" запускался калькулятор из второго задания. **Замечание**. Слова "угадайка", "калькулятор" и "покричи" принимать в любом регистре, то есть "Угадайка", "уГаДаЙкА" или иные варианты. Пользователю выводить меню доступных вариантов.

### Домашнее задание

1. Доработка программы из ПЗ2. Заменить множественные if на вызов функции из словаря. В dict вида {'func\_name': function} помещаете все реализованные. Ввод пользователя превращаете в строку вида 'func\_name', после чего выполняете конструкцию вида func = COMMANDS.get(cmd, cmd\_default). Полученная func используется для вызова нужной функции.

2. Реализовать меню вида "1. угадайка". Допускать ввод соответствующей цифры вместе с возможностью ввода названий подпрограмм. То есть ввод "1" или "угадайка" должен приводить к запуску соответствующей программы.

3. Проверка кода возврата - реализовать так, что exit выходит из подпрограммы и завершает основную программу с сообщением "завершена подпрограмма Х", где Х - это угадайка, калькулятор или покричи. Ввод q в подпрограмме должен завершать подпрограмму и выводить меню из доступных подпрограмм.

Всю работу вести в каталоге pz2, соблюдая названия файлов и функций из задания.


